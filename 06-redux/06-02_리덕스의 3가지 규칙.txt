✅하나의 애플리케이션 안에는 하나의 스토어가 있음

✅상태는 읽기 전용
- state를 업데이트 할 때?
    - setState를 사용
- 배열을 업데이트 할 때? 
    - 배열 자체에 push를 직접하지 않고, concat같은 함수를 사용하여 기존의 배열은 수정하지 않고, 새로운 배열을 만들어 교체하는 방식으로 업데이트
- 객체를 업데이트 할 때? 
    - 기존의 객체는 건드리지 않고, Object.assign을 사용하거나 spread 연산자를 사용하여 업데이트
- 기존의 상태를 건드리지 않고 새로운 상태를 생성하여 업데이트 해주는 방식으로 해주면, 나중에 개발자 도구를 통해 뒤로 돌릴 수도 있고 다시 앞으로 돌릴 수도 있음
- 리덕스에서 불변성을 유지해야 하는 이유?
    - 내부적으로 데이터가 변경되는 것을 감지하기 위하여 shallow equality 검사를 하기 때문
    - 이를 통하여 객체의 변화를 감지할 때 객체의 깊숙한 안쪽까지 비교하는 것이 아니라 겉핥기 식으로 비교하여 좋은 성능을 유지함
- Immutable.js 또는 Immer.js로 불변성을 유지하면서 상태를 관리 (https://velopert.com/3486)

✅변화를 일으키는 함수, 리듀서는 순수한 함수여야 함
- 순수한 함수?
    - 리듀서 함수는 이전 상태와, 액션 객체를 파라미터로 받음
    - 이전의 상태는 절대로 건드리지 않고, 변화를 일으킨 새로운 상태 객체를 만들어서 반환
    - 똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결과값을 반환해야 함 (동일한 인풋 => 동일한 아웃풋)
- ⚠️순수함을 해치는 작업들 => 리덕스 미들웨어 사용 필요!
    - new Date() 사용
    - 랜덤 숫자 생성
    - 네트워크에 요청